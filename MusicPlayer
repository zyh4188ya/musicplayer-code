import requests
import pandas as pd
import tkinter as tk
from tkinter import ttk, messagebox
from threading import Thread
import time
import webbrowser
from datetime import datetime


class NeteaseMusicCrawlerGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("ç½‘æ˜“äº‘éŸ³ä¹æ¦œå•çˆ¬è™« v1.0")
        self.root.geometry("1200x700")
        self.root.configure(bg="#f0f0f0")

        # æ¦œå•å®šä¹‰
        self.top_lists = {
            "é£™å‡æ¦œ": "19723756",
            "çƒ­æ­Œæ¦œ": "3778678",
            "æ–°æ­Œæ¦œ": "3779629",
            "åŸåˆ›æ¦œ": "2884035"
        }

        # æ•°æ®ç¼“å­˜
        self.data_cache = {}

        self.setup_ui()

    def setup_ui(self):
        # æ ‡é¢˜åŒºåŸŸ
        title_frame = tk.Frame(self.root, bg="#d43c33", height=80)
        title_frame.pack(fill="x", pady=(0, 20))
        title_frame.pack_propagate(False)

        title_label = tk.Label(title_frame, text="ğŸµ ç½‘æ˜“äº‘éŸ³ä¹æ¦œå•çˆ¬è™«",
                               font=("Microsoft YaHei", 24, "bold"),
                               fg="white", bg="#d43c33")
        title_label.pack(expand=True)

        subtitle_label = tk.Label(title_frame, text="é€‰æ‹©æ¦œå•æŸ¥çœ‹å®æ—¶æ’å",
                                  font=("Microsoft YaHei", 12),
                                  fg="white", bg="#d43c33")
        subtitle_label.pack(expand=True)

        # ä¸»å†…å®¹åŒºåŸŸ
        main_frame = tk.Frame(self.root, bg="#f0f0f0")
        main_frame.pack(fill="both", expand=True, padx=20, pady=(0, 20))

        # å·¦ä¾§æ§åˆ¶é¢æ¿
        left_frame = tk.Frame(main_frame, bg="#ffffff", width=250,
                              relief="solid", borderwidth=1)
        left_frame.pack(side="left", fill="y", padx=(0, 20))
        left_frame.pack_propagate(False)

        # æ¦œå•é€‰æ‹©æ ‡é¢˜
        list_title = tk.Label(left_frame, text="ğŸ“‹ æ¦œå•é€‰æ‹©",
                              font=("Microsoft YaHei", 14, "bold"),
                              bg="#ffffff", pady=15)
        list_title.pack(fill="x")

        # åˆ†éš”çº¿
        ttk.Separator(left_frame, orient="horizontal").pack(fill="x", padx=10)

        # æ¦œå•æŒ‰é’®
        self.list_buttons = {}
        for list_name in self.top_lists.keys():
            btn = tk.Button(left_frame, text=list_name,
                            font=("Microsoft YaHei", 12),
                            bg="#f8f9fa", fg="#333333",
                            relief="flat", height=2,
                            command=lambda name=list_name: self.select_list(name))
            btn.pack(fill="x", padx=15, pady=8)
            self.list_buttons[list_name] = btn

        # çˆ¬å–æ‰€æœ‰æŒ‰é’®
        ttk.Separator(left_frame, orient="horizontal").pack(fill="x", padx=10, pady=10)

        self.crawl_all_btn = tk.Button(left_frame, text="ğŸ”„ çˆ¬å–å…¨éƒ¨æ¦œå•",
                                       font=("Microsoft YaHei", 12, "bold"),
                                       bg="#1890ff", fg="white",
                                       command=self.crawl_all_lists,
                                       height=2)
        self.crawl_all_btn.pack(fill="x", padx=15, pady=5)

        # çŠ¶æ€ä¿¡æ¯
        self.status_label = tk.Label(left_frame, text="å°±ç»ª",
                                     font=("Microsoft YaHei", 10),
                                     bg="#ffffff", fg="#666666")
        self.status_label.pack(side="bottom", fill="x", padx=15, pady=15)

        # å³ä¾§æ•°æ®æ˜¾ç¤ºåŒºåŸŸ
        right_frame = tk.Frame(main_frame, bg="#ffffff",
                               relief="solid", borderwidth=1)
        right_frame.pack(side="left", fill="both", expand=True)

        # å½“å‰æ¦œå•ä¿¡æ¯
        info_frame = tk.Frame(right_frame, bg="#ffffff", height=70)
        info_frame.pack(fill="x", padx=20, pady=20)
        info_frame.pack_propagate(False)

        self.current_list_label = tk.Label(info_frame, text="è¯·é€‰æ‹©æ¦œå•",
                                           font=("Microsoft YaHei", 16, "bold"),
                                           bg="#ffffff", fg="#333333")
        self.current_list_label.pack(anchor="w")

        self.song_count_label = tk.Label(info_frame, text="",
                                         font=("Microsoft YaHei", 12),
                                         bg="#ffffff", fg="#666666")
        self.song_count_label.pack(anchor="w", pady=(5, 0))

        # æ•°æ®è¡¨æ ¼
        table_frame = tk.Frame(right_frame, bg="#ffffff")
        table_frame.pack(fill="both", expand=True, padx=20, pady=(0, 20))

        # åˆ›å»ºè¡¨æ ¼
        columns = ("æ’å", "æ­Œå", "æ­Œæ‰‹", "æ—¶é•¿", "æ’­æ”¾")
        self.tree = ttk.Treeview(table_frame, columns=columns,
                                 show="headings", height=20)

        # è®¾ç½®åˆ—å®½å’Œæ ‡é¢˜
        column_widths = {"æ’å": 60, "æ­Œå": 300, "æ­Œæ‰‹": 200, "æ—¶é•¿": 80, "æ’­æ”¾": 100}
        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=column_widths.get(col, 120),
                             anchor="center" if col in ["æ’å", "æ—¶é•¿", "æ’­æ”¾"] else "w")

        # æ·»åŠ æ»šåŠ¨æ¡
        scrollbar = ttk.Scrollbar(table_frame, orient="vertical",
                                  command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)

        self.tree.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # ç»‘å®šåŒå‡»äº‹ä»¶æ’­æ”¾æ­Œæ›²
        self.tree.bind("<Double-1>", self.play_song)

        # åº•éƒ¨æŒ‰é’®åŒºåŸŸ
        button_frame = tk.Frame(right_frame, bg="#ffffff", height=60)
        button_frame.pack(fill="x", padx=20, pady=(0, 20))
        button_frame.pack_propagate(False)

        self.export_btn = tk.Button(button_frame, text="ğŸ“¥ å¯¼å‡ºCSV",
                                    font=("Microsoft YaHei", 11),
                                    bg="#28a745", fg="white",
                                    state="disabled",
                                    command=self.export_to_csv)
        self.export_btn.pack(side="left", padx=(0, 10))

        self.refresh_btn = tk.Button(button_frame, text="ğŸ”„ åˆ·æ–°æ•°æ®",
                                     font=("Microsoft YaHei", 11),
                                     bg="#ffc107", fg="#333333",
                                     state="disabled",
                                     command=self.refresh_current_list)
        self.refresh_btn.pack(side="left")

        # å½“å‰é€‰æ‹©çš„æ¦œå•
        self.current_list = None

    def select_list(self, list_name):
        """é€‰æ‹©æ¦œå•å¹¶æ˜¾ç¤ºæ•°æ®"""
        self.current_list = list_name

        # é«˜äº®å½“å‰é€‰æ‹©çš„æŒ‰é’®
        for name, btn in self.list_buttons.items():
            if name == list_name:
                btn.config(bg="#e6f7ff", fg="#1890ff", font=("Microsoft YaHei", 12, "bold"))
            else:
                btn.config(bg="#f8f9fa", fg="#333333", font=("Microsoft YaHei", 12))

        # æ›´æ–°æ ‡é¢˜
        self.current_list_label.config(text=f"å½“å‰æ¦œå•ï¼š{list_name}")

        # æ£€æŸ¥æ˜¯å¦æœ‰ç¼“å­˜æ•°æ®
        if list_name in self.data_cache:
            self.display_data(self.data_cache[list_name])
            self.export_btn.config(state="normal")
            self.refresh_btn.config(state="normal")
        else:
            # æ²¡æœ‰ç¼“å­˜ï¼Œå¼€å§‹çˆ¬å–
            self.status_label.config(text=f"æ­£åœ¨çˆ¬å–{list_name}...", fg="#1890ff")
            self.song_count_label.config(text="æ­£åœ¨åŠ è½½æ•°æ®...")
            Thread(target=self.crawl_list, args=(list_name,), daemon=True).start()

    def crawl_list(self, list_name):
        """çˆ¬å–å•ä¸ªæ¦œå•æ•°æ®"""
        list_id = self.top_lists[list_name]
        songs = []

        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Referer': 'https://music.163.com/'
            }

            # ä½¿ç”¨APIè·å–æ•°æ®
            api_url = f'https://music.163.com/api/playlist/detail?id={list_id}'
            resp = requests.get(api_url, headers=headers, timeout=15)
            data = resp.json()

            if data['code'] == 200:
                tracks = data['result']['tracks'][:20]  # å‰20é¦–

                for idx, track in enumerate(tracks, start=1):
                    song = {
                        'æ’å': idx,
                        'æ­Œå': track['name'],
                        'æ­Œæ‰‹': ', '.join([artist['name'] for artist in track['artists']]),
                        'æ—¶é•¿': f"{track['duration'] // 60000}:{str(track['duration'] % 60000 // 1000).zfill(2)}",
                        'æ­Œæ›²ID': track['id'],
                        'æ’­æ”¾é“¾æ¥': f'http://music.163.com/song/media/outer/url?id={track["id"]}.mp3'
                    }
                    songs.append(song)

                # ç¼“å­˜æ•°æ®
                self.data_cache[list_name] = songs

                # æ›´æ–°UI
                self.root.after(0, self.display_data, songs)
                self.root.after(0, self.update_status,
                                f"æˆåŠŸçˆ¬å–{list_name} ({len(songs)}é¦–)", "#52c41a")
                self.root.after(0, lambda: self.export_btn.config(state="normal"))
                self.root.after(0, lambda: self.refresh_btn.config(state="normal"))
            else:
                self.root.after(0, self.update_status,
                                f"APIè¿”å›é”™è¯¯: {data.get('code')}", "#ff4d4f")

        except Exception as e:
            self.root.after(0, self.update_status,
                            f"çˆ¬å–å¤±è´¥: {str(e)}", "#ff4d4f")
            self.root.after(0, lambda: self.song_count_label.config(
                text=f"æ•°æ®åŠ è½½å¤±è´¥: {str(e)}"))

    def display_data(self, songs):
        """åœ¨è¡¨æ ¼ä¸­æ˜¾ç¤ºæ•°æ®"""
        # æ¸…ç©ºè¡¨æ ¼
        for item in self.tree.get_children():
            self.tree.delete(item)

        # æ’å…¥æ–°æ•°æ®
        for song in songs:
            self.tree.insert("", "end", values=(
                song['æ’å'],
                song['æ­Œå'],
                song['æ­Œæ‰‹'],
                song['æ—¶é•¿'],
                "â–¶ æ’­æ”¾"
            ), tags=(str(song['æ­Œæ›²ID']),))

        # æ›´æ–°æ­Œæ›²è®¡æ•°
        self.song_count_label.config(
            text=f"å…± {len(songs)} é¦–æ­Œæ›² | æœ€åæ›´æ–°: {datetime.now().strftime('%H:%M:%S')}")

    def play_song(self, event):
        """åŒå‡»æ’­æ”¾æ­Œæ›²"""
        item = self.tree.selection()[0]
        song_id = self.tree.item(item, "tags")[0]

        if song_id:
            url = f'http://music.163.com/song/media/outer/url?id={song_id}.mp3'
            webbrowser.open(url)
            self.update_status(f"æ­£åœ¨æ’­æ”¾æ­Œæ›² (ID: {song_id})", "#1890ff")

    def crawl_all_lists(self):
        """çˆ¬å–å…¨éƒ¨æ¦œå•"""
        self.crawl_all_btn.config(state="disabled", text="æ­£åœ¨çˆ¬å–...")
        self.update_status("å¼€å§‹çˆ¬å–å…¨éƒ¨æ¦œå•...", "#1890ff")

        def crawl_thread():
            success_count = 0
            for list_name in self.top_lists.keys():
                if list_name not in self.data_cache:
                    self.root.after(0, self.update_status,
                                    f"æ­£åœ¨çˆ¬å–: {list_name}", "#1890ff")

                    list_id = self.top_lists[list_name]
                    songs = []

                    try:
                        headers = {
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                            'Referer': 'https://music.163.com/'
                        }

                        api_url = f'https://music.163.com/api/playlist/detail?id={list_id}'
                        resp = requests.get(api_url, headers=headers, timeout=15)
                        data = resp.json()

                        if data['code'] == 200:
                            tracks = data['result']['tracks'][:20]

                            for idx, track in enumerate(tracks, start=1):
                                song = {
                                    'æ’å': idx,
                                    'æ­Œå': track['name'],
                                    'æ­Œæ‰‹': ', '.join([artist['name'] for artist in track['artists']]),
                                    'æ—¶é•¿': f"{track['duration'] // 60000}:{str(track['duration'] % 60000 // 1000).zfill(2)}",
                                    'æ­Œæ›²ID': track['id'],
                                    'æ’­æ”¾é“¾æ¥': f'http://music.163.com/song/media/outer/url?id={track["id"]}.mp3'
                                }
                                songs.append(song)

                            self.data_cache[list_name] = songs
                            success_count += 1

                        time.sleep(2)  # ç¤¼è²Œå»¶è¿Ÿ

                    except Exception as e:
                        print(f"çˆ¬å–{list_name}å¤±è´¥: {e}")

            # çˆ¬å–å®Œæˆ
            self.root.after(0, self.crawl_all_btn.config,
                            {"state": "normal", "text": "ğŸ”„ çˆ¬å–å…¨éƒ¨æ¦œå•"})
            self.root.after(0, self.update_status,
                            f"çˆ¬å–å®Œæˆï¼æˆåŠŸ {success_count}/{len(self.top_lists)} ä¸ªæ¦œå•",
                            "#52c41a")

            # å¦‚æœå½“å‰æœ‰é€‰ä¸­çš„æ¦œå•ï¼Œæ›´æ–°æ˜¾ç¤º
            if self.current_list and self.current_list in self.data_cache:
                self.root.after(0, self.display_data, self.data_cache[self.current_list])
                self.root.after(0, lambda: self.export_btn.config(state="normal"))
                self.root.after(0, lambda: self.refresh_btn.config(state="normal"))

        Thread(target=crawl_thread, daemon=True).start()

    def refresh_current_list(self):
        """åˆ·æ–°å½“å‰æ¦œå•æ•°æ®"""
        if self.current_list:
            self.update_status(f"åˆ·æ–°{self_current_list}...", "#1890ff")
            self.refresh_btn.config(state="disabled")

            def refresh_thread():
                # ä»ç¼“å­˜ä¸­ç§»é™¤å½“å‰æ¦œå•ï¼Œè§¦å‘é‡æ–°çˆ¬å–
                if self.current_list in self.data_cache:
                    del self.data_cache[self.current_list]

                # é‡æ–°çˆ¬å–
                self.crawl_list(self.current_list)
                self.root.after(0, lambda: self.refresh_btn.config(state="normal"))

            Thread(target=refresh_thread, daemon=True).start()

    def export_to_csv(self):
        """å¯¼å‡ºå½“å‰æ¦œå•æ•°æ®ä¸ºCSV"""
        if self.current_list and self.current_list in self.data_cache:
            songs = self.data_cache[self.current_list]
            df = pd.DataFrame(songs)

            # ç§»é™¤æ­Œæ›²IDåˆ—ï¼ˆç”¨äºå†…éƒ¨ä½¿ç”¨ï¼‰
            if 'æ­Œæ›²ID' in df.columns:
                df = df.drop(columns=['æ­Œæ›²ID'])

            filename = f"ç½‘æ˜“äº‘éŸ³ä¹_{self.current_list}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            df.to_csv(filename, index=False, encoding='utf-8-sig')

            messagebox.showinfo("å¯¼å‡ºæˆåŠŸ", f"æ•°æ®å·²å¯¼å‡ºåˆ°:\n{filename}")
            self.update_status(f"æ•°æ®å·²å¯¼å‡º: {filename}", "#52c41a")

    def update_status(self, message, color="#666666"):
        """æ›´æ–°çŠ¶æ€æ ä¿¡æ¯"""
        self.status_label.config(text=message, fg=color)


def main():
    root = tk.Tk()
    app = NeteaseMusicCrawlerGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()
